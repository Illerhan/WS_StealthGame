;
; Note: shader requires additional functionality:
;       Wave level operations
;       64-Bit integer
;       64-bit Atomics on Typed Resources
;
;
; Input signature:
;
; Name                 Index   Mask Register SysValue  Format   Used
; -------------------- ----- ------ -------- -------- ------- ------
; no parameters
;
; Output signature:
;
; Name                 Index   Mask Register SysValue  Format   Used
; -------------------- ----- ------ -------- -------- ------- ------
; no parameters
; shader hash: bb9caedfccf125a4998b104275464e72
;
; Pipeline Runtime Information: 
;
; Compute Shader
; NumThreads=(64,1,1)
;
;
; Buffer Definitions:
;
; cbuffer $Globals
; {
;
;   struct $Globals
;   {
;
;       uint GPUSceneFrameNumber;                     ; Offset:    0
;       uint4 PageConstants;                          ; Offset:   16
;       uint MaxNodes;                                ; Offset:   32
;       uint MaxVisibleClusters;                      ; Offset:   36
;       uint RenderFlags;                             ; Offset:   40
;       float RayTracingCutError;                     ; Offset:   44
;       uint DebugFlags;                              ; Offset:   48
;       float2 HZBViewSize;                           ; Offset:   52
;       float2 HZBSize;                               ; Offset:   64
;       float4 DepthOfFieldParams;                    ; Offset:   80
;       uint bSceneLightingChannelsValid;             ; Offset:   96
;       uint MaxCandidateClusters;                    ; Offset:  100
;       uint ActiveRasterizerBin;                     ; Offset:  104
;       float2 HardwareViewportSize;                  ; Offset:  112
;       uint VisualizeModeBitMask;                    ; Offset:  120
;   
;   } $Globals;                                       ; Offset:    0 Size:   124
;
; }
;
; Resource bind info for GPUScenePrimitiveSceneData
; {
;
;   float4 $Element;                                  ; Offset:    0 Size:    16
;
; }
;
; Resource bind info for GPUSceneInstanceSceneData
; {
;
;   float4 $Element;                                  ; Offset:    0 Size:    16
;
; }
;
; Resource bind info for InViews
; {
;
;   struct hostlayout.struct.FPackedNaniteView
;   {
;
;       row_major float4x4 SVPositionToTranslatedWorld;; Offset:    0
;       row_major float4x4 ViewToTranslatedWorld;     ; Offset:   64
;       row_major float4x4 TranslatedWorldToView;     ; Offset:  128
;       row_major float4x4 TranslatedWorldToClip;     ; Offset:  192
;       row_major float4x4 TranslatedWorldToSubpixelClip;; Offset:  256
;       row_major float4x4 ViewToClip;                ; Offset:  320
;       row_major float4x4 ClipToRelativeWorld;       ; Offset:  384
;       row_major float4x4 PrevTranslatedWorldToView; ; Offset:  448
;       row_major float4x4 PrevTranslatedWorldToClip; ; Offset:  512
;       row_major float4x4 PrevViewToClip;            ; Offset:  576
;       row_major float4x4 PrevClipToRelativeWorld;   ; Offset:  640
;       int4 ViewRect;                                ; Offset:  704
;       float4 ViewSizeAndInvSize;                    ; Offset:  720
;       float4 ClipSpaceScaleOffset;                  ; Offset:  736
;       float3 RelativePreViewTranslation;            ; Offset:  752
;       float ViewTilePositionX;                      ; Offset:  764
;       float3 RelativePrevPreViewTranslation;        ; Offset:  768
;       float ViewTilePositionY;                      ; Offset:  780
;       float3 RelativeWorldCameraOrigin;             ; Offset:  784
;       float ViewTilePositionZ;                      ; Offset:  796
;       float3 DrawDistanceOriginTranslatedWorld;     ; Offset:  800
;       float RangeBasedCullingDistance;              ; Offset:  812
;       float3 ViewForward;                           ; Offset:  816
;       float NearPlane;                              ; Offset:  828
;       float4 TranslatedGlobalClipPlane;             ; Offset:  832
;       float3 MatrixTilePosition;                    ; Offset:  848
;       float Padding1;                               ; Offset:  860
;       float2 LODScales;                             ; Offset:  864
;       float MinBoundsRadiusSq;                      ; Offset:  872
;       uint StreamingPriorityCategory_AndFlags;      ; Offset:  876
;       int4 TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ;; Offset:  880
;       int4 HZBTestViewRect;                         ; Offset:  896
;   
;   } $Element;                                       ; Offset:    0 Size:   912
;
; }
;
; Resource bind info for RasterizerBinHeaders
; {
;
;   uint4 $Element;                                   ; Offset:    0 Size:    16
;
; }
;
; Resource bind info for RasterizerBinData
; {
;
;   uint2 $Element;                                   ; Offset:    0 Size:     8
;
; }
;
; Resource bind info for InTotalPrevDrawClusters
; {
;
;   uint2 $Element;                                   ; Offset:    0 Size:     8
;
; }
;
;
; Resource Bindings:
;
; Name                                 Type  Format         Dim      ID      HLSL Bind  Count
; ------------------------------ ---------- ------- ----------- ------- -------------- ------
; $Globals                          cbuffer      NA          NA     CB0            cb0     1
; GPUScenePrimitiveSceneData        texture  struct         r/o      T0             t0     1
; GPUSceneInstanceSceneData         texture  struct         r/o      T1             t1     1
; ClusterPageData                   texture    byte         r/o      T2             t2     1
; VisibleClustersSWHW               texture    byte         r/o      T3             t3     1
; InViews                           texture  struct         r/o      T4             t4     1
; RasterizerBinHeaders              texture  struct         r/o      T5             t5     1
; RasterizerBinData                 texture  struct         r/o      T6             t6     1
; InTotalPrevDrawClusters           texture  struct         r/o      T7             t7     1
; InClusterOffsetSWHW               texture     u32         buf      T8             t8     1
; OutVisBuffer64                        UAV     u32          2d      U0             u0     1
; OutDbgBuffer64                        UAV     u32          2d      U1             u1     1
; OutDbgBuffer32                        UAV     u32          2d      U2             u2     1
;
target datalayout = "e-m:e-p:32:32-i1:32-i8:32-i16:32-i32:32-i64:64-f16:32-f32:32-f64:64-n8:16:32:64"
target triple = "dxil-ms-dx"

%dx.types.Handle = type { i8* }
%dx.types.ResBind = type { i32, i32, i32, i8 }
%dx.types.ResourceProperties = type { i32, i32 }
%dx.types.CBufRet.i32 = type { i32, i32, i32, i32 }
%dx.types.ResRet.i32 = type { i32, i32, i32, i32, i32 }
%dx.types.ResRet.f32 = type { float, float, float, float, i32 }
%"class.StructuredBuffer<vector<float, 4> >" = type { <4 x float> }
%struct.ByteAddressBuffer = type { i32 }
%"hostlayout.class.StructuredBuffer<FPackedNaniteView>" = type { %hostlayout.struct.FPackedNaniteView }
%hostlayout.struct.FPackedNaniteView = type { [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], [4 x <4 x float>], <4 x i32>, <4 x float>, <4 x float>, <3 x float>, float, <3 x float>, float, <3 x float>, float, <3 x float>, float, <3 x float>, float, <4 x float>, <3 x float>, float, <2 x float>, float, i32, <4 x i32>, <4 x i32> }
%"class.StructuredBuffer<vector<unsigned int, 4> >" = type { <4 x i32> }
%"class.StructuredBuffer<vector<unsigned int, 2> >" = type { <2 x i32> }
%"class.Buffer<unsigned int>" = type { i32 }
%"class.RWTexture2D<unsigned long long>" = type { i64 }
%"class.RWTexture2D<unsigned int>" = type { i32 }
%"$Globals" = type { i32, <4 x i32>, i32, i32, i32, float, i32, <2 x float>, <2 x float>, <4 x float>, i32, i32, i32, <2 x float>, i32 }

@"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim" = addrspace(3) global [768 x float] undef, align 4

define void @MicropolyRasterize() {
  %1 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 2, i32 2, i32 0, i8 1 }, i32 2, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %2 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 1, i32 1, i32 0, i8 1 }, i32 1, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %3 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 0, i32 0, i32 0, i8 1 }, i32 0, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %4 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 8, i32 8, i32 0, i8 0 }, i32 8, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %5 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 7, i32 7, i32 0, i8 0 }, i32 7, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %6 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 6, i32 6, i32 0, i8 0 }, i32 6, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %7 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 5, i32 5, i32 0, i8 0 }, i32 5, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %8 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 4, i32 4, i32 0, i8 0 }, i32 4, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %9 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 3, i32 3, i32 0, i8 0 }, i32 3, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %10 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 2, i32 2, i32 0, i8 0 }, i32 2, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %11 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 1, i32 1, i32 0, i8 0 }, i32 1, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %12 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind zeroinitializer, i32 0, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %13 = call %dx.types.Handle @dx.op.createHandleFromBinding(i32 217, %dx.types.ResBind { i32 0, i32 0, i32 0, i8 2 }, i32 0, i1 false)  ; CreateHandleFromBinding(bind,index,nonUniformIndex)
  %14 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %13, %dx.types.ResourceProperties { i32 13, i32 124 })  ; AnnotateHandle(res,props)  resource: CBuffer
  %15 = call i32 @dx.op.groupId.i32(i32 94, i32 0)  ; GroupId(component)
  %16 = call i32 @dx.op.flattenedThreadIdInGroup.i32(i32 96)  ; FlattenedThreadIdInGroup()
  %17 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %14, i32 2)  ; CBufferLoadLegacy(handle,regIndex)
  %18 = extractvalue %dx.types.CBufRet.i32 %17, 2
  %19 = and i32 %18, 4096
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %21, label %34, !dx.controlflow.hints !30

; <label>:21                                      ; preds = %0
  %22 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %14, i32 6)  ; CBufferLoadLegacy(handle,regIndex)
  %23 = extractvalue %dx.types.CBufRet.i32 %22, 2
  %24 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %7, %dx.types.ResourceProperties { i32 12, i32 16 })  ; AnnotateHandle(res,props)  resource: StructuredBuffer<stride=16>
  %25 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %24, i32 %23, i32 0, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %26 = extractvalue %dx.types.ResRet.i32 %25, 2
  %27 = add i32 %26, %15
  %28 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %6, %dx.types.ResourceProperties { i32 12, i32 8 })  ; AnnotateHandle(res,props)  resource: StructuredBuffer<stride=8>
  %29 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %28, i32 %27, i32 0, i8 3, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %30 = extractvalue %dx.types.ResRet.i32 %29, 0
  %31 = extractvalue %dx.types.ResRet.i32 %29, 1
  %32 = lshr i32 %31, 16
  %33 = and i32 %31, 65535
  br label %34

; <label>:34                                      ; preds = %21, %0
  %35 = phi i32 [ %30, %21 ], [ %15, %0 ]
  %36 = phi i32 [ %32, %21 ], [ undef, %0 ]
  %37 = phi i32 [ %33, %21 ], [ undef, %0 ]
  %38 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %14, i32 2)  ; CBufferLoadLegacy(handle,regIndex)
  %39 = extractvalue %dx.types.CBufRet.i32 %38, 2
  %40 = and i32 %39, 8192
  %41 = icmp eq i32 %40, 0
  br i1 %41, label %47, label %42, !dx.controlflow.hints !31

; <label>:42                                      ; preds = %34
  %43 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %5, %dx.types.ResourceProperties { i32 12, i32 8 })  ; AnnotateHandle(res,props)  resource: StructuredBuffer<stride=8>
  %44 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %43, i32 0, i32 0, i8 3, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %45 = extractvalue %dx.types.ResRet.i32 %44, 0
  %46 = add i32 %45, %35
  br label %47

; <label>:47                                      ; preds = %42, %34
  %48 = phi i32 [ %46, %42 ], [ %35, %34 ]
  %49 = and i32 %39, 2048
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %56, label %51, !dx.controlflow.hints !32

; <label>:51                                      ; preds = %47
  %52 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %4, %dx.types.ResourceProperties { i32 10, i32 261 })  ; AnnotateHandle(res,props)  resource: TypedBuffer<U32>
  %53 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %52, i32 0, i32 undef)  ; BufferLoad(srv,index,wot)
  %54 = extractvalue %dx.types.ResRet.i32 %53, 0
  %55 = add i32 %54, %48
  br label %56

; <label>:56                                      ; preds = %51, %47
  %57 = phi i32 [ %55, %51 ], [ %48, %47 ]
  %58 = shl i32 %57, 3
  %59 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %9, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %60 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %59, i32 %58, i32 undef, i8 3, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %61 = extractvalue %dx.types.ResRet.i32 %60, 0
  %62 = extractvalue %dx.types.ResRet.i32 %60, 1
  %63 = lshr i32 %61, 4
  %64 = and i32 %63, 4095
  %65 = lshr i32 %61, 16
  %66 = and i32 %62, 16777215
  %67 = lshr i32 %62, 24
  %68 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %14, i32 1)  ; CBufferLoadLegacy(handle,regIndex)
  %69 = extractvalue %dx.types.CBufRet.i32 %68, 0
  %70 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %11, %dx.types.ResourceProperties { i32 12, i32 16 })  ; AnnotateHandle(res,props)  resource: StructuredBuffer<stride=16>
  %71 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %70, i32 %66, i32 0, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %72 = extractvalue %dx.types.ResRet.f32 %71, 0
  %73 = bitcast float %72 to i32
  %74 = and i32 %73, 1048575
  %75 = mul nuw nsw i32 %74, 41
  %76 = add nuw nsw i32 %75, 1
  %77 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %12, %dx.types.ResourceProperties { i32 12, i32 16 })  ; AnnotateHandle(res,props)  resource: StructuredBuffer<stride=16>
  %78 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %77, i32 %76, i32 0, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %79 = extractvalue %dx.types.ResRet.f32 %78, 0
  %80 = extractvalue %dx.types.ResRet.f32 %78, 1
  %81 = extractvalue %dx.types.ResRet.f32 %78, 2
  %82 = add i32 %69, %66
  %83 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %70, i32 %82, i32 0, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %84 = extractvalue %dx.types.ResRet.f32 %83, 0
  %85 = extractvalue %dx.types.ResRet.f32 %83, 1
  %86 = extractvalue %dx.types.ResRet.f32 %83, 2
  %87 = extractvalue %dx.types.ResRet.f32 %83, 3
  %88 = bitcast float %84 to i32
  %89 = bitcast float %85 to i32
  %90 = bitcast float %86 to i32
  %91 = bitcast float %87 to i32
  %92 = shl i32 %69, 1
  %93 = add i32 %92, %66
  %94 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %70, i32 %93, i32 0, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %95 = extractvalue %dx.types.ResRet.f32 %94, 0
  %96 = extractvalue %dx.types.ResRet.f32 %94, 1
  %97 = extractvalue %dx.types.ResRet.f32 %94, 2
  %98 = and i32 %88, 65535
  %99 = uitofp i32 %98 to float
  %100 = lshr i32 %88, 16
  %101 = uitofp i32 %100 to float
  %102 = and i32 %89, 32767
  %103 = uitofp i32 %102 to float
  %104 = fadd fast float %99, -3.276800e+04
  %105 = fadd fast float %101, -3.276800e+04
  %106 = fadd fast float %103, -1.638400e+04
  %107 = fmul fast float %106, 0x3F06A0F8E0000000
  %108 = and i32 %89, 32768
  %109 = icmp ne i32 %108, 0
  %110 = fadd fast float %104, %105
  %111 = fmul fast float %110, 0x3F00002000000000
  %112 = fsub fast float %104, %105
  %113 = fmul fast float %112, 0x3F00002000000000
  %114 = call float @dx.op.unary.f32(i32 6, float %111)  ; FAbs(value)
  %115 = call float @dx.op.unary.f32(i32 6, float %113)  ; FAbs(value)
  %116 = call float @dx.op.dot2.f32(i32 54, float 1.000000e+00, float 1.000000e+00, float %114, float %115)  ; Dot2(ax,ay,bx,by)
  %117 = fsub fast float 2.000000e+00, %116
  %118 = call float @dx.op.dot3.f32(i32 55, float %111, float %113, float %117, float %111, float %113, float %117)  ; Dot3(ax,ay,az,bx,by,bz)
  %119 = call float @dx.op.unary.f32(i32 25, float %118)  ; Rsqrt(value)
  %120 = fmul fast float %119, %111
  %121 = fmul fast float %119, %113
  %122 = fmul fast float %119, %117
  %123 = fadd fast float %122, 1.000000e+00
  %124 = fdiv fast float 1.000000e+00, %123
  %125 = fmul fast float %121, %120
  %126 = fmul fast float %125, %124
  %127 = fsub fast float -0.000000e+00, %126
  %128 = fmul fast float %120, %120
  %129 = fmul fast float %128, %124
  %130 = fsub fast float 1.000000e+00, %129
  %131 = fmul fast float %121, %121
  %132 = fmul fast float %131, %124
  %133 = fsub fast float 1.000000e+00, %132
  %134 = fmul fast float %107, %107
  %135 = fsub fast float 1.000000e+00, %134
  %136 = call float @dx.op.unary.f32(i32 24, float %135)  ; Sqrt(value)
  %137 = select i1 %109, float %107, float %136
  %138 = select i1 %109, float %136, float %107
  %139 = fmul fast float %130, %137
  %140 = fmul fast float %137, %127
  %141 = fmul fast float %137, %120
  %142 = fmul fast float %138, %127
  %143 = fmul fast float %133, %138
  %144 = fmul fast float %121, %138
  %145 = fsub fast float -0.000000e+00, %144
  %146 = fadd fast float %139, %142
  %147 = fadd fast float %140, %143
  %148 = fsub fast float %145, %141
  %149 = fmul fast float %148, %121
  %150 = fmul fast float %147, %122
  %151 = fsub fast float %149, %150
  %152 = fmul fast float %146, %122
  %153 = fmul fast float %148, %120
  %154 = fsub fast float %152, %153
  %155 = fmul fast float %147, %120
  %156 = fmul fast float %146, %121
  %157 = fsub fast float %155, %156
  %158 = lshr i32 %91, 16
  %159 = shl i32 %158, 23
  %160 = add i32 %159, -125829120
  %161 = bitcast i32 %160 to float
  %162 = lshr i32 %90, 16
  %163 = and i32 %90, 65535
  %164 = and i32 %91, 65535
  %165 = uitofp i32 %163 to float
  %166 = uitofp i32 %162 to float
  %167 = uitofp i32 %164 to float
  %168 = fadd fast float %165, -3.276800e+04
  %169 = fadd fast float %166, -3.276800e+04
  %170 = fadd fast float %167, -3.276800e+04
  %171 = fmul fast float %161, %168
  %172 = fmul fast float %161, %169
  %173 = fmul fast float %161, %170
  %174 = fmul fast float %146, %171
  %175 = fmul fast float %147, %171
  %176 = fmul fast float %148, %171
  %177 = fmul fast float %151, %172
  %178 = fmul fast float %154, %172
  %179 = fmul fast float %157, %172
  %180 = fmul fast float %120, %173
  %181 = fmul fast float %121, %173
  %182 = fmul fast float %122, %173
  %183 = and i32 %73, 1048576
  %184 = icmp ne i32 %183, 0
  %185 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %8, %dx.types.ResourceProperties { i32 524, i32 912 })  ; AnnotateHandle(res,props)  resource: StructuredBuffer<stride=912>
  %186 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 192, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %187 = extractvalue %dx.types.ResRet.f32 %186, 0
  %188 = extractvalue %dx.types.ResRet.f32 %186, 1
  %189 = extractvalue %dx.types.ResRet.f32 %186, 2
  %190 = extractvalue %dx.types.ResRet.f32 %186, 3
  %191 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 208, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %192 = extractvalue %dx.types.ResRet.f32 %191, 0
  %193 = extractvalue %dx.types.ResRet.f32 %191, 1
  %194 = extractvalue %dx.types.ResRet.f32 %191, 2
  %195 = extractvalue %dx.types.ResRet.f32 %191, 3
  %196 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 224, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %197 = extractvalue %dx.types.ResRet.f32 %196, 0
  %198 = extractvalue %dx.types.ResRet.f32 %196, 1
  %199 = extractvalue %dx.types.ResRet.f32 %196, 2
  %200 = extractvalue %dx.types.ResRet.f32 %196, 3
  %201 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 240, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %202 = extractvalue %dx.types.ResRet.f32 %201, 0
  %203 = extractvalue %dx.types.ResRet.f32 %201, 1
  %204 = extractvalue %dx.types.ResRet.f32 %201, 2
  %205 = extractvalue %dx.types.ResRet.f32 %201, 3
  %206 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %185, i32 %64, i32 704, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %207 = extractvalue %dx.types.ResRet.i32 %206, 0
  %208 = extractvalue %dx.types.ResRet.i32 %206, 1
  %209 = extractvalue %dx.types.ResRet.i32 %206, 2
  %210 = extractvalue %dx.types.ResRet.i32 %206, 3
  %211 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 720, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %212 = extractvalue %dx.types.ResRet.f32 %211, 0
  %213 = extractvalue %dx.types.ResRet.f32 %211, 1
  %214 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 752, i8 7, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %215 = extractvalue %dx.types.ResRet.f32 %214, 0
  %216 = extractvalue %dx.types.ResRet.f32 %214, 1
  %217 = extractvalue %dx.types.ResRet.f32 %214, 2
  %218 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 764, i8 1, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %219 = extractvalue %dx.types.ResRet.f32 %218, 0
  %220 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 780, i8 1, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %221 = extractvalue %dx.types.ResRet.f32 %220, 0
  %222 = call %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32 139, %dx.types.Handle %185, i32 %64, i32 796, i8 1, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %223 = extractvalue %dx.types.ResRet.f32 %222, 0
  %224 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %185, i32 %64, i32 876, i8 1, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %225 = extractvalue %dx.types.ResRet.i32 %224, 0
  %226 = and i32 %225, 64
  %227 = icmp ne i32 %226, 0
  %228 = xor i1 %184, %227
  %229 = fsub fast float %79, %219
  %230 = fsub fast float %80, %221
  %231 = fsub fast float %81, %223
  %232 = fmul fast float %229, 2.097152e+06
  %233 = fmul fast float %230, 2.097152e+06
  %234 = fmul fast float %231, 2.097152e+06
  %235 = fadd fast float %215, %95
  %236 = fadd fast float %235, %232
  %237 = fadd fast float %216, %96
  %238 = fadd fast float %237, %233
  %239 = fadd fast float %217, %97
  %240 = fadd fast float %239, %234
  %241 = extractvalue %dx.types.CBufRet.i32 %68, 1
  %242 = call i32 @dx.op.binary.i32(i32 40, i32 %65, i32 %241)  ; UMin(a,b)
  %243 = shl i32 %242, 17
  %244 = sub nsw i32 %65, %241
  %245 = call i32 @dx.op.binary.i32(i32 37, i32 %244, i32 0)  ; IMax(a,b)
  %246 = shl i32 %245, 15
  %247 = add i32 %246, %243
  %248 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %10, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %249 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %248, i32 %247, i32 undef, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %250 = extractvalue %dx.types.ResRet.i32 %249, 0
  %251 = shl i32 %250, 4
  %252 = shl nuw nsw i32 %67, 4
  %253 = or i32 %247, %252
  %254 = add nsw i32 %253, 16
  %255 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %248, i32 %254, i32 undef, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %256 = extractvalue %dx.types.ResRet.i32 %255, 0
  %257 = extractvalue %dx.types.ResRet.i32 %255, 1
  %258 = add i32 %254, %251
  %259 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %248, i32 %258, i32 undef, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %260 = extractvalue %dx.types.ResRet.i32 %259, 0
  %261 = extractvalue %dx.types.ResRet.i32 %259, 1
  %262 = extractvalue %dx.types.ResRet.i32 %259, 2
  %263 = extractvalue %dx.types.ResRet.i32 %259, 3
  %264 = and i32 %256, 511
  %265 = and i32 %257, 255
  %266 = lshr i32 %257, 8
  %267 = and i32 %263, 15
  %268 = lshr i32 %263, 9
  %269 = and i32 %268, 31
  %270 = lshr i32 %263, 14
  %271 = and i32 %270, 31
  %272 = lshr i32 %263, 19
  %273 = and i32 %272, 31
  %274 = sub i32 %37, %36
  %275 = select i1 %20, i32 %274, i32 %265
  %276 = select i1 %20, i32 %36, i32 0
  %277 = fmul fast float %212, 5.000000e-01
  %278 = fmul fast float %213, 5.000000e-01
  %279 = sitofp i32 %207 to float
  %280 = sitofp i32 %208 to float
  %281 = fadd fast float %277, %279
  %282 = fadd fast float %278, %280
  %283 = fmul fast float %212, 1.280000e+02
  %284 = fmul fast float %213, -1.280000e+02
  %285 = fmul fast float %281, 2.560000e+02
  %286 = fmul fast float %282, 2.560000e+02
  %287 = fadd fast float %285, 5.000000e-01
  %288 = fadd fast float %286, 5.000000e-01
  %289 = icmp ult i32 %16, %264
  br i1 %289, label %290, label %723, !dx.controlflow.hints !33

; <label>:290                                     ; preds = %56
  %291 = lshr i32 %256, 9
  %292 = add nuw nsw i32 %269, %271
  %293 = add nuw nsw i32 %292, %273
  %294 = mul i32 %293, %16
  %295 = add i32 %291, %247
  %296 = lshr i32 %294, 5
  %297 = shl nuw nsw i32 %296, 2
  %298 = add i32 %295, %297
  %299 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %248, i32 %298, i32 undef, i8 7, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %300 = extractvalue %dx.types.ResRet.i32 %299, 0
  %301 = extractvalue %dx.types.ResRet.i32 %299, 1
  %302 = extractvalue %dx.types.ResRet.i32 %299, 2
  %303 = and i32 %294, 31
  %304 = lshr i32 %300, %303
  %305 = icmp eq i32 %303, 0
  br i1 %305, label %310, label %306

; <label>:306                                     ; preds = %290
  %307 = sub i32 0, %294
  %308 = and i32 %307, 31
  %309 = shl i32 %301, %308
  br label %310

; <label>:310                                     ; preds = %306, %290
  %311 = phi i32 [ %309, %306 ], [ 0, %290 ]
  %312 = or i32 %311, %304
  %313 = lshr i32 %301, %303
  br i1 %305, label %318, label %314

; <label>:314                                     ; preds = %310
  %315 = sub i32 0, %294
  %316 = and i32 %315, 31
  %317 = shl i32 %302, %316
  br label %318

; <label>:318                                     ; preds = %314, %310
  %319 = phi i32 [ %317, %314 ], [ 0, %310 ]
  %320 = or i32 %319, %313
  %321 = shl i32 1, %269
  %322 = add i32 %321, -1
  %323 = and i32 %312, %322
  %324 = lshr i32 %312, %269
  %325 = icmp eq i32 %269, 0
  br i1 %325, label %330, label %326

; <label>:326                                     ; preds = %318
  %327 = sub nsw i32 0, %268
  %328 = and i32 %327, 31
  %329 = shl i32 %320, %328
  br label %330

; <label>:330                                     ; preds = %326, %318
  %331 = phi i32 [ %329, %326 ], [ 0, %318 ]
  %332 = or i32 %331, %324
  %333 = shl i32 1, %271
  %334 = add i32 %333, -1
  %335 = and i32 %332, %334
  %336 = lshr i32 %332, %271
  %337 = icmp eq i32 %271, 0
  br i1 %337, label %343, label %338

; <label>:338                                     ; preds = %330
  %339 = lshr i32 %320, %269
  %340 = sub nsw i32 0, %270
  %341 = and i32 %340, 31
  %342 = shl i32 %339, %341
  br label %343

; <label>:343                                     ; preds = %338, %330
  %344 = phi i32 [ %342, %338 ], [ 0, %330 ]
  %345 = or i32 %344, %336
  %346 = shl i32 1, %273
  %347 = add i32 %346, -1
  %348 = and i32 %345, %347
  %349 = shl i32 %263, 19
  %350 = and i32 %349, 260046848
  %351 = sub nsw i32 1132462080, %350
  %352 = bitcast i32 %351 to float
  %353 = add i32 %323, %260
  %354 = add i32 %335, %261
  %355 = add i32 %348, %262
  %356 = sitofp i32 %353 to float
  %357 = sitofp i32 %354 to float
  %358 = sitofp i32 %355 to float
  %359 = fmul fast float %356, %352
  %360 = fmul fast float %357, %352
  %361 = fmul fast float %358, %352
  %362 = fmul fast float %359, %174
  %363 = call float @dx.op.tertiary.f32(i32 46, float %360, float %177, float %362)  ; FMad(a,b,c)
  %364 = call float @dx.op.tertiary.f32(i32 46, float %361, float %180, float %363)  ; FMad(a,b,c)
  %365 = fadd fast float %364, %236
  %366 = fmul fast float %359, %175
  %367 = call float @dx.op.tertiary.f32(i32 46, float %360, float %178, float %366)  ; FMad(a,b,c)
  %368 = call float @dx.op.tertiary.f32(i32 46, float %361, float %181, float %367)  ; FMad(a,b,c)
  %369 = fadd fast float %368, %238
  %370 = fmul fast float %359, %176
  %371 = call float @dx.op.tertiary.f32(i32 46, float %360, float %179, float %370)  ; FMad(a,b,c)
  %372 = call float @dx.op.tertiary.f32(i32 46, float %361, float %182, float %371)  ; FMad(a,b,c)
  %373 = fadd fast float %372, %240
  %374 = fmul fast float %365, %187
  %375 = call float @dx.op.tertiary.f32(i32 46, float %369, float %192, float %374)  ; FMad(a,b,c)
  %376 = call float @dx.op.tertiary.f32(i32 46, float %373, float %197, float %375)  ; FMad(a,b,c)
  %377 = fadd fast float %376, %202
  %378 = fmul fast float %365, %188
  %379 = call float @dx.op.tertiary.f32(i32 46, float %369, float %193, float %378)  ; FMad(a,b,c)
  %380 = call float @dx.op.tertiary.f32(i32 46, float %373, float %198, float %379)  ; FMad(a,b,c)
  %381 = fadd fast float %380, %203
  %382 = fmul fast float %365, %189
  %383 = call float @dx.op.tertiary.f32(i32 46, float %369, float %194, float %382)  ; FMad(a,b,c)
  %384 = call float @dx.op.tertiary.f32(i32 46, float %373, float %199, float %383)  ; FMad(a,b,c)
  %385 = fadd fast float %384, %204
  %386 = fmul fast float %365, %190
  %387 = call float @dx.op.tertiary.f32(i32 46, float %369, float %195, float %386)  ; FMad(a,b,c)
  %388 = call float @dx.op.tertiary.f32(i32 46, float %373, float %200, float %387)  ; FMad(a,b,c)
  %389 = fadd fast float %388, %205
  %390 = fdiv fast float %377, %389
  %391 = fdiv fast float %381, %389
  %392 = fdiv fast float %385, %389
  %393 = fmul fast float %390, %283
  %394 = fmul fast float %391, %284
  %395 = fadd fast float %393, %287
  %396 = fadd fast float %394, %288
  %397 = call float @dx.op.unary.f32(i32 27, float %395)  ; Round_ni(value)
  %398 = call float @dx.op.unary.f32(i32 27, float %396)  ; Round_ni(value)
  %399 = mul i32 %16, 3
  %400 = add i32 0, %399
  %401 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %400
  store float %397, float addrspace(3)* %401, align 4
  %402 = mul i32 %16, 3
  %403 = add i32 1, %402
  %404 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %403
  store float %398, float addrspace(3)* %404, align 4
  %405 = mul i32 %16, 3
  %406 = add i32 2, %405
  %407 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %406
  store float %392, float addrspace(3)* %407, align 4
  %408 = add i32 %16, 64
  %409 = icmp ult i32 %408, %264
  br i1 %409, label %410, label %723, !dx.controlflow.hints !33

; <label>:410                                     ; preds = %343
  %411 = mul i32 %293, %408
  %412 = lshr i32 %411, 5
  %413 = shl nuw nsw i32 %412, 2
  %414 = add i32 %295, %413
  %415 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %10, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %416 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %415, i32 %414, i32 undef, i8 7, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %417 = extractvalue %dx.types.ResRet.i32 %416, 0
  %418 = extractvalue %dx.types.ResRet.i32 %416, 1
  %419 = extractvalue %dx.types.ResRet.i32 %416, 2
  %420 = and i32 %411, 31
  %421 = lshr i32 %417, %420
  %422 = icmp eq i32 %420, 0
  br i1 %422, label %427, label %423

; <label>:423                                     ; preds = %410
  %424 = sub i32 0, %411
  %425 = and i32 %424, 31
  %426 = shl i32 %418, %425
  br label %427

; <label>:427                                     ; preds = %423, %410
  %428 = phi i32 [ %426, %423 ], [ 0, %410 ]
  %429 = or i32 %428, %421
  %430 = lshr i32 %418, %420
  br i1 %422, label %435, label %431

; <label>:431                                     ; preds = %427
  %432 = sub i32 0, %411
  %433 = and i32 %432, 31
  %434 = shl i32 %419, %433
  br label %435

; <label>:435                                     ; preds = %431, %427
  %436 = phi i32 [ %434, %431 ], [ 0, %427 ]
  %437 = or i32 %436, %430
  %438 = and i32 %429, %322
  %439 = lshr i32 %429, %269
  br i1 %325, label %444, label %440

; <label>:440                                     ; preds = %435
  %441 = sub nsw i32 0, %268
  %442 = and i32 %441, 31
  %443 = shl i32 %437, %442
  br label %444

; <label>:444                                     ; preds = %440, %435
  %445 = phi i32 [ %443, %440 ], [ 0, %435 ]
  %446 = or i32 %445, %439
  %447 = and i32 %446, %334
  %448 = lshr i32 %446, %271
  br i1 %337, label %454, label %449

; <label>:449                                     ; preds = %444
  %450 = lshr i32 %437, %269
  %451 = sub nsw i32 0, %270
  %452 = and i32 %451, 31
  %453 = shl i32 %450, %452
  br label %454

; <label>:454                                     ; preds = %449, %444
  %455 = phi i32 [ %453, %449 ], [ 0, %444 ]
  %456 = or i32 %455, %448
  %457 = and i32 %456, %347
  %458 = add i32 %438, %260
  %459 = add i32 %447, %261
  %460 = add i32 %457, %262
  %461 = sitofp i32 %458 to float
  %462 = sitofp i32 %459 to float
  %463 = sitofp i32 %460 to float
  %464 = fmul fast float %461, %352
  %465 = fmul fast float %462, %352
  %466 = fmul fast float %463, %352
  %467 = fmul fast float %464, %174
  %468 = call float @dx.op.tertiary.f32(i32 46, float %465, float %177, float %467)  ; FMad(a,b,c)
  %469 = call float @dx.op.tertiary.f32(i32 46, float %466, float %180, float %468)  ; FMad(a,b,c)
  %470 = fadd fast float %469, %236
  %471 = fmul fast float %464, %175
  %472 = call float @dx.op.tertiary.f32(i32 46, float %465, float %178, float %471)  ; FMad(a,b,c)
  %473 = call float @dx.op.tertiary.f32(i32 46, float %466, float %181, float %472)  ; FMad(a,b,c)
  %474 = fadd fast float %473, %238
  %475 = fmul fast float %464, %176
  %476 = call float @dx.op.tertiary.f32(i32 46, float %465, float %179, float %475)  ; FMad(a,b,c)
  %477 = call float @dx.op.tertiary.f32(i32 46, float %466, float %182, float %476)  ; FMad(a,b,c)
  %478 = fadd fast float %477, %240
  %479 = fmul fast float %470, %187
  %480 = call float @dx.op.tertiary.f32(i32 46, float %474, float %192, float %479)  ; FMad(a,b,c)
  %481 = call float @dx.op.tertiary.f32(i32 46, float %478, float %197, float %480)  ; FMad(a,b,c)
  %482 = fadd fast float %481, %202
  %483 = fmul fast float %470, %188
  %484 = call float @dx.op.tertiary.f32(i32 46, float %474, float %193, float %483)  ; FMad(a,b,c)
  %485 = call float @dx.op.tertiary.f32(i32 46, float %478, float %198, float %484)  ; FMad(a,b,c)
  %486 = fadd fast float %485, %203
  %487 = fmul fast float %470, %189
  %488 = call float @dx.op.tertiary.f32(i32 46, float %474, float %194, float %487)  ; FMad(a,b,c)
  %489 = call float @dx.op.tertiary.f32(i32 46, float %478, float %199, float %488)  ; FMad(a,b,c)
  %490 = fadd fast float %489, %204
  %491 = fmul fast float %470, %190
  %492 = call float @dx.op.tertiary.f32(i32 46, float %474, float %195, float %491)  ; FMad(a,b,c)
  %493 = call float @dx.op.tertiary.f32(i32 46, float %478, float %200, float %492)  ; FMad(a,b,c)
  %494 = fadd fast float %493, %205
  %495 = fdiv fast float %482, %494
  %496 = fdiv fast float %486, %494
  %497 = fdiv fast float %490, %494
  %498 = fmul fast float %495, %283
  %499 = fmul fast float %496, %284
  %500 = fadd fast float %498, %287
  %501 = fadd fast float %499, %288
  %502 = call float @dx.op.unary.f32(i32 27, float %500)  ; Round_ni(value)
  %503 = call float @dx.op.unary.f32(i32 27, float %501)  ; Round_ni(value)
  %504 = mul i32 %408, 3
  %505 = add i32 0, %504
  %506 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %505
  store float %502, float addrspace(3)* %506, align 4
  %507 = mul i32 %408, 3
  %508 = add i32 1, %507
  %509 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %508
  store float %503, float addrspace(3)* %509, align 4
  %510 = mul i32 %408, 3
  %511 = add i32 2, %510
  %512 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %511
  store float %497, float addrspace(3)* %512, align 4
  %513 = add i32 %16, 128
  %514 = icmp ult i32 %513, %264
  br i1 %514, label %515, label %723, !dx.controlflow.hints !33

; <label>:515                                     ; preds = %454
  %516 = mul i32 %293, %513
  %517 = lshr i32 %516, 5
  %518 = shl nuw nsw i32 %517, 2
  %519 = add i32 %295, %518
  %520 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %10, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %521 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %520, i32 %519, i32 undef, i8 7, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %522 = extractvalue %dx.types.ResRet.i32 %521, 0
  %523 = extractvalue %dx.types.ResRet.i32 %521, 1
  %524 = extractvalue %dx.types.ResRet.i32 %521, 2
  %525 = and i32 %516, 31
  %526 = lshr i32 %522, %525
  %527 = icmp eq i32 %525, 0
  br i1 %527, label %532, label %528

; <label>:528                                     ; preds = %515
  %529 = sub i32 0, %516
  %530 = and i32 %529, 31
  %531 = shl i32 %523, %530
  br label %532

; <label>:532                                     ; preds = %528, %515
  %533 = phi i32 [ %531, %528 ], [ 0, %515 ]
  %534 = or i32 %533, %526
  %535 = lshr i32 %523, %525
  br i1 %527, label %540, label %536

; <label>:536                                     ; preds = %532
  %537 = sub i32 0, %516
  %538 = and i32 %537, 31
  %539 = shl i32 %524, %538
  br label %540

; <label>:540                                     ; preds = %536, %532
  %541 = phi i32 [ %539, %536 ], [ 0, %532 ]
  %542 = or i32 %541, %535
  %543 = and i32 %534, %322
  %544 = lshr i32 %534, %269
  br i1 %325, label %549, label %545

; <label>:545                                     ; preds = %540
  %546 = sub nsw i32 0, %268
  %547 = and i32 %546, 31
  %548 = shl i32 %542, %547
  br label %549

; <label>:549                                     ; preds = %545, %540
  %550 = phi i32 [ %548, %545 ], [ 0, %540 ]
  %551 = or i32 %550, %544
  %552 = and i32 %551, %334
  %553 = lshr i32 %551, %271
  br i1 %337, label %559, label %554

; <label>:554                                     ; preds = %549
  %555 = lshr i32 %542, %269
  %556 = sub nsw i32 0, %270
  %557 = and i32 %556, 31
  %558 = shl i32 %555, %557
  br label %559

; <label>:559                                     ; preds = %554, %549
  %560 = phi i32 [ %558, %554 ], [ 0, %549 ]
  %561 = or i32 %560, %553
  %562 = and i32 %561, %347
  %563 = add i32 %543, %260
  %564 = add i32 %552, %261
  %565 = add i32 %562, %262
  %566 = sitofp i32 %563 to float
  %567 = sitofp i32 %564 to float
  %568 = sitofp i32 %565 to float
  %569 = fmul fast float %566, %352
  %570 = fmul fast float %567, %352
  %571 = fmul fast float %568, %352
  %572 = fmul fast float %569, %174
  %573 = call float @dx.op.tertiary.f32(i32 46, float %570, float %177, float %572)  ; FMad(a,b,c)
  %574 = call float @dx.op.tertiary.f32(i32 46, float %571, float %180, float %573)  ; FMad(a,b,c)
  %575 = fadd fast float %574, %236
  %576 = fmul fast float %569, %175
  %577 = call float @dx.op.tertiary.f32(i32 46, float %570, float %178, float %576)  ; FMad(a,b,c)
  %578 = call float @dx.op.tertiary.f32(i32 46, float %571, float %181, float %577)  ; FMad(a,b,c)
  %579 = fadd fast float %578, %238
  %580 = fmul fast float %569, %176
  %581 = call float @dx.op.tertiary.f32(i32 46, float %570, float %179, float %580)  ; FMad(a,b,c)
  %582 = call float @dx.op.tertiary.f32(i32 46, float %571, float %182, float %581)  ; FMad(a,b,c)
  %583 = fadd fast float %582, %240
  %584 = fmul fast float %575, %187
  %585 = call float @dx.op.tertiary.f32(i32 46, float %579, float %192, float %584)  ; FMad(a,b,c)
  %586 = call float @dx.op.tertiary.f32(i32 46, float %583, float %197, float %585)  ; FMad(a,b,c)
  %587 = fadd fast float %586, %202
  %588 = fmul fast float %575, %188
  %589 = call float @dx.op.tertiary.f32(i32 46, float %579, float %193, float %588)  ; FMad(a,b,c)
  %590 = call float @dx.op.tertiary.f32(i32 46, float %583, float %198, float %589)  ; FMad(a,b,c)
  %591 = fadd fast float %590, %203
  %592 = fmul fast float %575, %189
  %593 = call float @dx.op.tertiary.f32(i32 46, float %579, float %194, float %592)  ; FMad(a,b,c)
  %594 = call float @dx.op.tertiary.f32(i32 46, float %583, float %199, float %593)  ; FMad(a,b,c)
  %595 = fadd fast float %594, %204
  %596 = fmul fast float %575, %190
  %597 = call float @dx.op.tertiary.f32(i32 46, float %579, float %195, float %596)  ; FMad(a,b,c)
  %598 = call float @dx.op.tertiary.f32(i32 46, float %583, float %200, float %597)  ; FMad(a,b,c)
  %599 = fadd fast float %598, %205
  %600 = fdiv fast float %587, %599
  %601 = fdiv fast float %591, %599
  %602 = fdiv fast float %595, %599
  %603 = fmul fast float %600, %283
  %604 = fmul fast float %601, %284
  %605 = fadd fast float %603, %287
  %606 = fadd fast float %604, %288
  %607 = call float @dx.op.unary.f32(i32 27, float %605)  ; Round_ni(value)
  %608 = call float @dx.op.unary.f32(i32 27, float %606)  ; Round_ni(value)
  %609 = mul i32 %513, 3
  %610 = add i32 0, %609
  %611 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %610
  store float %607, float addrspace(3)* %611, align 4
  %612 = mul i32 %513, 3
  %613 = add i32 1, %612
  %614 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %613
  store float %608, float addrspace(3)* %614, align 4
  %615 = mul i32 %513, 3
  %616 = add i32 2, %615
  %617 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %616
  store float %602, float addrspace(3)* %617, align 4
  %618 = add i32 %16, 192
  %619 = icmp ult i32 %618, %264
  br i1 %619, label %620, label %723, !dx.controlflow.hints !33

; <label>:620                                     ; preds = %559
  %621 = mul i32 %293, %618
  %622 = lshr i32 %621, 5
  %623 = shl nuw nsw i32 %622, 2
  %624 = add i32 %295, %623
  %625 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %10, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %626 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %625, i32 %624, i32 undef, i8 7, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %627 = extractvalue %dx.types.ResRet.i32 %626, 0
  %628 = extractvalue %dx.types.ResRet.i32 %626, 1
  %629 = extractvalue %dx.types.ResRet.i32 %626, 2
  %630 = and i32 %621, 31
  %631 = lshr i32 %627, %630
  %632 = icmp eq i32 %630, 0
  br i1 %632, label %637, label %633

; <label>:633                                     ; preds = %620
  %634 = sub i32 0, %621
  %635 = and i32 %634, 31
  %636 = shl i32 %628, %635
  br label %637

; <label>:637                                     ; preds = %633, %620
  %638 = phi i32 [ %636, %633 ], [ 0, %620 ]
  %639 = or i32 %638, %631
  %640 = lshr i32 %628, %630
  br i1 %632, label %645, label %641

; <label>:641                                     ; preds = %637
  %642 = sub i32 0, %621
  %643 = and i32 %642, 31
  %644 = shl i32 %629, %643
  br label %645

; <label>:645                                     ; preds = %641, %637
  %646 = phi i32 [ %644, %641 ], [ 0, %637 ]
  %647 = or i32 %646, %640
  %648 = and i32 %639, %322
  %649 = lshr i32 %639, %269
  br i1 %325, label %654, label %650

; <label>:650                                     ; preds = %645
  %651 = sub nsw i32 0, %268
  %652 = and i32 %651, 31
  %653 = shl i32 %647, %652
  br label %654

; <label>:654                                     ; preds = %650, %645
  %655 = phi i32 [ %653, %650 ], [ 0, %645 ]
  %656 = or i32 %655, %649
  %657 = and i32 %656, %334
  %658 = lshr i32 %656, %271
  br i1 %337, label %664, label %659

; <label>:659                                     ; preds = %654
  %660 = lshr i32 %647, %269
  %661 = sub nsw i32 0, %270
  %662 = and i32 %661, 31
  %663 = shl i32 %660, %662
  br label %664

; <label>:664                                     ; preds = %659, %654
  %665 = phi i32 [ %663, %659 ], [ 0, %654 ]
  %666 = or i32 %665, %658
  %667 = and i32 %666, %347
  %668 = add i32 %648, %260
  %669 = add i32 %657, %261
  %670 = add i32 %667, %262
  %671 = sitofp i32 %668 to float
  %672 = sitofp i32 %669 to float
  %673 = sitofp i32 %670 to float
  %674 = fmul fast float %671, %352
  %675 = fmul fast float %672, %352
  %676 = fmul fast float %673, %352
  %677 = fmul fast float %674, %174
  %678 = call float @dx.op.tertiary.f32(i32 46, float %675, float %177, float %677)  ; FMad(a,b,c)
  %679 = call float @dx.op.tertiary.f32(i32 46, float %676, float %180, float %678)  ; FMad(a,b,c)
  %680 = fadd fast float %679, %236
  %681 = fmul fast float %674, %175
  %682 = call float @dx.op.tertiary.f32(i32 46, float %675, float %178, float %681)  ; FMad(a,b,c)
  %683 = call float @dx.op.tertiary.f32(i32 46, float %676, float %181, float %682)  ; FMad(a,b,c)
  %684 = fadd fast float %683, %238
  %685 = fmul fast float %674, %176
  %686 = call float @dx.op.tertiary.f32(i32 46, float %675, float %179, float %685)  ; FMad(a,b,c)
  %687 = call float @dx.op.tertiary.f32(i32 46, float %676, float %182, float %686)  ; FMad(a,b,c)
  %688 = fadd fast float %687, %240
  %689 = fmul fast float %680, %187
  %690 = call float @dx.op.tertiary.f32(i32 46, float %684, float %192, float %689)  ; FMad(a,b,c)
  %691 = call float @dx.op.tertiary.f32(i32 46, float %688, float %197, float %690)  ; FMad(a,b,c)
  %692 = fadd fast float %691, %202
  %693 = fmul fast float %680, %188
  %694 = call float @dx.op.tertiary.f32(i32 46, float %684, float %193, float %693)  ; FMad(a,b,c)
  %695 = call float @dx.op.tertiary.f32(i32 46, float %688, float %198, float %694)  ; FMad(a,b,c)
  %696 = fadd fast float %695, %203
  %697 = fmul fast float %680, %189
  %698 = call float @dx.op.tertiary.f32(i32 46, float %684, float %194, float %697)  ; FMad(a,b,c)
  %699 = call float @dx.op.tertiary.f32(i32 46, float %688, float %199, float %698)  ; FMad(a,b,c)
  %700 = fadd fast float %699, %204
  %701 = fmul fast float %680, %190
  %702 = call float @dx.op.tertiary.f32(i32 46, float %684, float %195, float %701)  ; FMad(a,b,c)
  %703 = call float @dx.op.tertiary.f32(i32 46, float %688, float %200, float %702)  ; FMad(a,b,c)
  %704 = fadd fast float %703, %205
  %705 = fdiv fast float %692, %704
  %706 = fdiv fast float %696, %704
  %707 = fdiv fast float %700, %704
  %708 = fmul fast float %705, %283
  %709 = fmul fast float %706, %284
  %710 = fadd fast float %708, %287
  %711 = fadd fast float %709, %288
  %712 = call float @dx.op.unary.f32(i32 27, float %710)  ; Round_ni(value)
  %713 = call float @dx.op.unary.f32(i32 27, float %711)  ; Round_ni(value)
  %714 = mul i32 %618, 3
  %715 = add i32 0, %714
  %716 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %715
  store float %712, float addrspace(3)* %716, align 4
  %717 = mul i32 %618, 3
  %718 = add i32 1, %717
  %719 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %718
  store float %713, float addrspace(3)* %719, align 4
  %720 = mul i32 %618, 3
  %721 = add i32 2, %720
  %722 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %721
  store float %707, float addrspace(3)* %722, align 4
  br label %723

; <label>:723                                     ; preds = %664, %559, %454, %343, %56
  call void @dx.op.barrier(i32 80, i32 9)  ; Barrier(barrierMode)
  %724 = add i32 %276, %16
  %725 = add nuw nsw i32 %267, 10
  %726 = mul i32 %725, %724
  %727 = add i32 %266, %247
  %728 = ashr i32 %726, 5
  %729 = shl nsw i32 %728, 2
  %730 = add i32 %727, %729
  %731 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %10, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %732 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %731, i32 %730, i32 undef, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %733 = extractvalue %dx.types.ResRet.i32 %732, 0
  %734 = and i32 %726, 31
  %735 = lshr i32 %733, %734
  %736 = icmp eq i32 %734, 0
  br i1 %736, label %742, label %737

; <label>:737                                     ; preds = %723
  %738 = extractvalue %dx.types.ResRet.i32 %732, 1
  %739 = sub i32 0, %726
  %740 = and i32 %739, 31
  %741 = shl i32 %738, %740
  br label %742

; <label>:742                                     ; preds = %737, %723
  %743 = phi i32 [ %741, %737 ], [ 0, %723 ]
  %744 = or i32 %743, %735
  %745 = shl i32 1, %267
  %746 = add i32 %745, -1
  %747 = and i32 %744, %746
  %748 = lshr i32 %744, %267
  %749 = and i32 %748, 31
  %750 = add nuw nsw i32 %267, 5
  %751 = lshr i32 %744, %750
  %752 = and i32 %751, 31
  %753 = add i32 %749, %747
  %754 = add i32 %752, %747
  %755 = select i1 %228, i32 %754, i32 %753
  %756 = select i1 %228, i32 %753, i32 %754
  %757 = mul i32 %747, 3
  %758 = add i32 0, %757
  %759 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %758
  %760 = load float, float addrspace(3)* %759, align 4
  %761 = mul i32 %747, 3
  %762 = add i32 1, %761
  %763 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %762
  %764 = load float, float addrspace(3)* %763, align 4
  %765 = mul i32 %747, 3
  %766 = add i32 2, %765
  %767 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %766
  %768 = load float, float addrspace(3)* %767, align 4
  %769 = mul i32 %755, 3
  %770 = add i32 0, %769
  %771 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %770
  %772 = load float, float addrspace(3)* %771, align 4
  %773 = mul i32 %755, 3
  %774 = add i32 1, %773
  %775 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %774
  %776 = load float, float addrspace(3)* %775, align 4
  %777 = mul i32 %756, 3
  %778 = add i32 0, %777
  %779 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %778
  %780 = load float, float addrspace(3)* %779, align 4
  %781 = mul i32 %756, 3
  %782 = add i32 1, %781
  %783 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %782
  %784 = load float, float addrspace(3)* %783, align 4
  %785 = icmp ult i32 %16, %275
  br i1 %785, label %786, label %1395, !dx.controlflow.hints !34

; <label>:786                                     ; preds = %742
  %787 = mul i32 %756, 3
  %788 = add i32 2, %787
  %789 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %788
  %790 = load float, float addrspace(3)* %789, align 4
  %791 = mul i32 %755, 3
  %792 = add i32 2, %791
  %793 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %792
  %794 = load float, float addrspace(3)* %793, align 4
  %795 = fsub fast float %772, %760
  %796 = fsub fast float %776, %764
  %797 = fsub fast float %780, %760
  %798 = fsub fast float %784, %764
  %799 = fmul fast float %798, %795
  %800 = fmul fast float %797, %796
  %801 = fsub fast float %799, %800
  %802 = fcmp ult float %801, 0.000000e+00
  %803 = call float @dx.op.binary.f32(i32 36, float %772, float %780)  ; FMin(a,b)
  %804 = call float @dx.op.binary.f32(i32 36, float %760, float %803)  ; FMin(a,b)
  %805 = call float @dx.op.binary.f32(i32 36, float %776, float %784)  ; FMin(a,b)
  %806 = call float @dx.op.binary.f32(i32 36, float %764, float %805)  ; FMin(a,b)
  %807 = call float @dx.op.binary.f32(i32 35, float %772, float %780)  ; FMax(a,b)
  %808 = call float @dx.op.binary.f32(i32 35, float %760, float %807)  ; FMax(a,b)
  %809 = call float @dx.op.binary.f32(i32 35, float %776, float %784)  ; FMax(a,b)
  %810 = call float @dx.op.binary.f32(i32 35, float %764, float %809)  ; FMax(a,b)
  %811 = fadd fast float %804, 1.270000e+02
  %812 = fadd fast float %806, 1.270000e+02
  %813 = fmul fast float %811, 3.906250e-03
  %814 = fmul fast float %812, 3.906250e-03
  %815 = call float @dx.op.unary.f32(i32 27, float %813)  ; Round_ni(value)
  %816 = call float @dx.op.unary.f32(i32 27, float %814)  ; Round_ni(value)
  %817 = fptosi float %815 to i32
  %818 = fptosi float %816 to i32
  %819 = fadd fast float %808, -1.290000e+02
  %820 = fadd fast float %810, -1.290000e+02
  %821 = fmul fast float %819, 3.906250e-03
  %822 = fmul fast float %820, 3.906250e-03
  %823 = call float @dx.op.unary.f32(i32 27, float %821)  ; Round_ni(value)
  %824 = call float @dx.op.unary.f32(i32 27, float %822)  ; Round_ni(value)
  %825 = fptosi float %823 to i32
  %826 = fptosi float %824 to i32
  %827 = call i32 @dx.op.binary.i32(i32 37, i32 %817, i32 %207)  ; IMax(a,b)
  %828 = call i32 @dx.op.binary.i32(i32 37, i32 %818, i32 %208)  ; IMax(a,b)
  %829 = add i32 %209, -1
  %830 = add i32 %210, -1
  %831 = call i32 @dx.op.binary.i32(i32 38, i32 %825, i32 %829)  ; IMin(a,b)
  %832 = call i32 @dx.op.binary.i32(i32 38, i32 %826, i32 %830)  ; IMin(a,b)
  %833 = add i32 %827, 63
  %834 = add i32 %828, 63
  %835 = call i32 @dx.op.binary.i32(i32 38, i32 %831, i32 %833)  ; IMin(a,b)
  %836 = call i32 @dx.op.binary.i32(i32 38, i32 %832, i32 %834)  ; IMin(a,b)
  %837 = fsub fast float -0.000000e+00, %796
  %838 = fsub fast float %772, %780
  %839 = fsub fast float %776, %784
  %840 = sitofp i32 %827 to float
  %841 = sitofp i32 %828 to float
  %842 = fmul fast float %840, 2.560000e+02
  %843 = fmul fast float %841, 2.560000e+02
  %844 = fadd fast float %842, 1.280000e+02
  %845 = fadd fast float %843, 1.280000e+02
  %846 = fsub fast float %760, %844
  %847 = fsub fast float %764, %845
  %848 = fsub fast float %772, %844
  %849 = fsub fast float %776, %845
  %850 = fsub fast float %780, %844
  %851 = fsub fast float %784, %845
  %852 = fmul fast float %848, %839
  %853 = fmul fast float %849, %838
  %854 = fsub fast float %852, %853
  %855 = fmul fast float %850, %798
  %856 = fmul fast float %851, %797
  %857 = fsub fast float %855, %856
  %858 = fmul fast float %846, %837
  %859 = fmul fast float %847, %795
  %860 = fadd fast float %859, %858
  %861 = fsub fast float 1.000000e+00, %838
  %862 = call float @dx.op.unary.f32(i32 7, float %861)  ; Saturate(value)
  %863 = fadd fast float %862, %839
  %864 = call float @dx.op.unary.f32(i32 7, float %863)  ; Saturate(value)
  %865 = fsub fast float %854, %864
  %866 = fsub fast float 1.000000e+00, %797
  %867 = call float @dx.op.unary.f32(i32 7, float %866)  ; Saturate(value)
  %868 = fadd fast float %867, %798
  %869 = call float @dx.op.unary.f32(i32 7, float %868)  ; Saturate(value)
  %870 = fsub fast float %857, %869
  %871 = fadd fast float %795, 1.000000e+00
  %872 = call float @dx.op.unary.f32(i32 7, float %871)  ; Saturate(value)
  %873 = fsub fast float %872, %796
  %874 = call float @dx.op.unary.f32(i32 7, float %873)  ; Saturate(value)
  %875 = fsub fast float %860, %874
  %876 = fmul fast float %865, 3.906250e-03
  %877 = fmul fast float %870, 3.906250e-03
  %878 = fmul fast float %875, 3.906250e-03
  %879 = fsub fast float %794, %768
  %880 = fsub fast float %790, %768
  %881 = fadd fast float %870, %865
  %882 = fadd fast float %881, %875
  %883 = fmul fast float %882, 3.906250e-03
  %884 = fdiv fast float %879, %883
  %885 = fdiv fast float %880, %883
  %886 = icmp sge i32 %835, %827
  %887 = icmp sle i32 %828, %836
  %888 = and i1 %886, %887
  %889 = and i1 %802, %888
  br i1 %889, label %890, label %1062

; <label>:890                                     ; preds = %786
  %891 = shl i32 %57, 7
  %892 = add i32 %891, 128
  %893 = or i32 %892, %724
  %894 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %14, i32 7)  ; CBufferLoadLegacy(handle,regIndex)
  %895 = extractvalue %dx.types.CBufRet.i32 %894, 2
  %896 = lshr i32 %895, 6
  %897 = and i32 %896, 1
  %898 = sub nsw i32 %835, %827
  %899 = icmp sgt i32 %898, 4
  %900 = call i1 @dx.op.waveAnyTrue(i32 113, i1 %899)  ; WaveAnyTrue(cond)
  br i1 %900, label %971, label %901

; <label>:901                                     ; preds = %890
  br label %902

; <label>:902                                     ; preds = %966, %901
  %903 = phi float [ %967, %966 ], [ %876, %901 ]
  %904 = phi float [ %968, %966 ], [ %877, %901 ]
  %905 = phi float [ %969, %966 ], [ %878, %901 ]
  %906 = phi i32 [ %970, %966 ], [ %828, %901 ]
  %907 = call float @dx.op.binary.f32(i32 36, float %904, float %905)  ; FMin(a,b)
  %908 = call float @dx.op.binary.f32(i32 36, float %903, float %907)  ; FMin(a,b)
  %909 = fcmp fast ult float %908, 0.000000e+00
  br i1 %909, label %928, label %910

; <label>:910                                     ; preds = %902
  %911 = fmul fast float %904, %884
  %912 = fadd fast float %911, %768
  %913 = fmul fast float %905, %885
  %914 = fadd fast float %912, %913
  %915 = call float @dx.op.unary.f32(i32 7, float %914)  ; Saturate(value)
  %916 = bitcast float %915 to i32
  %917 = zext i32 %916 to i64
  %918 = shl nuw i64 %917, 32
  %919 = zext i32 %893 to i64
  %920 = or i64 %918, %919
  %921 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %3, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %922 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %921, i32 7, i32 %827, i32 %906, i32 undef, i64 %920)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %923 = or i64 %918, 2
  %924 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %2, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %925 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %924, i32 7, i32 %827, i32 %906, i32 undef, i64 %923)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %926 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %1, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %927 = call i32 @dx.op.atomicBinOp.i32(i32 78, %dx.types.Handle %926, i32 0, i32 %827, i32 %906, i32 undef, i32 %897)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  br label %928

; <label>:928                                     ; preds = %910, %902
  %929 = icmp sgt i32 %835, %827
  br i1 %929, label %930, label %964

; <label>:930                                     ; preds = %928
  br label %931

; <label>:931                                     ; preds = %961, %930
  %932 = phi float [ %936, %961 ], [ %903, %930 ]
  %933 = phi float [ %937, %961 ], [ %904, %930 ]
  %934 = phi float [ %938, %961 ], [ %905, %930 ]
  %935 = phi i32 [ %939, %961 ], [ %827, %930 ]
  %936 = fsub fast float %932, %839
  %937 = fsub fast float %933, %798
  %938 = fadd fast float %934, %796
  %939 = add nsw i32 %935, 1
  %940 = call float @dx.op.binary.f32(i32 36, float %937, float %938)  ; FMin(a,b)
  %941 = call float @dx.op.binary.f32(i32 36, float %936, float %940)  ; FMin(a,b)
  %942 = fcmp fast ult float %941, 0.000000e+00
  br i1 %942, label %961, label %943

; <label>:943                                     ; preds = %931
  %944 = fmul fast float %937, %884
  %945 = fadd fast float %944, %768
  %946 = fmul fast float %938, %885
  %947 = fadd fast float %945, %946
  %948 = call float @dx.op.unary.f32(i32 7, float %947)  ; Saturate(value)
  %949 = bitcast float %948 to i32
  %950 = zext i32 %949 to i64
  %951 = shl nuw i64 %950, 32
  %952 = zext i32 %893 to i64
  %953 = or i64 %951, %952
  %954 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %3, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %955 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %954, i32 7, i32 %939, i32 %906, i32 undef, i64 %953)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %956 = or i64 %951, 2
  %957 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %2, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %958 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %957, i32 7, i32 %939, i32 %906, i32 undef, i64 %956)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %959 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %1, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %960 = call i32 @dx.op.atomicBinOp.i32(i32 78, %dx.types.Handle %959, i32 0, i32 %939, i32 %906, i32 undef, i32 %897)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  br label %961

; <label>:961                                     ; preds = %943, %931
  %962 = icmp eq i32 %939, %835
  br i1 %962, label %963, label %931

; <label>:963                                     ; preds = %961
  br label %964

; <label>:964                                     ; preds = %963, %928
  %965 = icmp slt i32 %906, %836
  br i1 %965, label %966, label %1061

; <label>:966                                     ; preds = %964
  %967 = fadd fast float %903, %838
  %968 = fadd fast float %904, %797
  %969 = fsub fast float %905, %795
  %970 = add nsw i32 %906, 1
  br label %902

; <label>:971                                     ; preds = %890
  %972 = fcmp fast olt float %839, 0.000000e+00
  %973 = fcmp fast olt float %798, 0.000000e+00
  %974 = fcmp ogt float %796, -0.000000e+00
  %975 = fdiv fast float 1.000000e+00, %839
  %976 = fdiv fast float 1.000000e+00, %798
  %977 = fdiv fast float 1.000000e+00, %837
  %978 = fcmp fast oeq float %839, 0.000000e+00
  %979 = fcmp fast oeq float %798, 0.000000e+00
  %980 = fcmp oeq float %796, -0.000000e+00
  %981 = select i1 %978, float 1.000000e+08, float %975
  %982 = select i1 %979, float 1.000000e+08, float %976
  %983 = select i1 %980, float 1.000000e+08, float %977
  br label %984

; <label>:984                                     ; preds = %1055, %971
  %985 = phi float [ %876, %971 ], [ %1056, %1055 ]
  %986 = phi float [ %877, %971 ], [ %1057, %1055 ]
  %987 = phi float [ %878, %971 ], [ %1058, %1055 ]
  %988 = phi i32 [ %828, %971 ], [ %1059, %1055 ]
  %989 = fmul fast float %985, %981
  %990 = fmul fast float %986, %982
  %991 = fmul fast float %987, %983
  %992 = select i1 %972, float %989, float 0.000000e+00
  %993 = select i1 %973, float %990, float 0.000000e+00
  %994 = select i1 %974, float %991, float 0.000000e+00
  %995 = fptosi float %989 to i32
  %996 = fptosi float %990 to i32
  %997 = fptosi float %991 to i32
  %998 = select i1 %972, i32 %898, i32 %995
  %999 = select i1 %973, i32 %898, i32 %996
  %1000 = select i1 %974, i32 %898, i32 %997
  %1001 = sitofp i32 %998 to float
  %1002 = sitofp i32 %999 to float
  %1003 = sitofp i32 %1000 to float
  %1004 = call float @dx.op.binary.f32(i32 35, float %993, float %994)  ; FMax(a,b)
  %1005 = call float @dx.op.binary.f32(i32 35, float %992, float %1004)  ; FMax(a,b)
  %1006 = call float @dx.op.unary.f32(i32 28, float %1005)  ; Round_pi(value)
  %1007 = call float @dx.op.binary.f32(i32 36, float %1002, float %1003)  ; FMin(a,b)
  %1008 = call float @dx.op.binary.f32(i32 36, float %1001, float %1007)  ; FMin(a,b)
  %1009 = fadd fast float %1006, %840
  %1010 = fadd fast float %1008, %840
  %1011 = fcmp fast ugt float %1009, %1010
  br i1 %1011, label %1053, label %1012

; <label>:1012                                    ; preds = %984
  %1013 = fmul fast float %1006, %837
  %1014 = fsub fast float %987, %1013
  %1015 = fmul fast float %1006, %798
  %1016 = fsub fast float %986, %1015
  %1017 = fmul fast float %1006, %839
  %1018 = fsub fast float %985, %1017
  br label %1019

; <label>:1019                                    ; preds = %1046, %1012
  %1020 = phi float [ %1047, %1046 ], [ %1018, %1012 ]
  %1021 = phi float [ %1048, %1046 ], [ %1016, %1012 ]
  %1022 = phi float [ %1049, %1046 ], [ %1014, %1012 ]
  %1023 = phi float [ %1050, %1046 ], [ %1009, %1012 ]
  %1024 = call float @dx.op.binary.f32(i32 36, float %1021, float %1022)  ; FMin(a,b)
  %1025 = call float @dx.op.binary.f32(i32 36, float %1020, float %1024)  ; FMin(a,b)
  %1026 = fcmp fast ult float %1025, 0.000000e+00
  br i1 %1026, label %1046, label %1027

; <label>:1027                                    ; preds = %1019
  %1028 = fptoui float %1023 to i32
  %1029 = fmul fast float %1021, %884
  %1030 = fadd fast float %1029, %768
  %1031 = fmul fast float %1022, %885
  %1032 = fadd fast float %1030, %1031
  %1033 = call float @dx.op.unary.f32(i32 7, float %1032)  ; Saturate(value)
  %1034 = bitcast float %1033 to i32
  %1035 = zext i32 %1034 to i64
  %1036 = shl nuw i64 %1035, 32
  %1037 = zext i32 %893 to i64
  %1038 = or i64 %1036, %1037
  %1039 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %3, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1040 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1039, i32 7, i32 %1028, i32 %988, i32 undef, i64 %1038)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1041 = or i64 %1036, 2
  %1042 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %2, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1043 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1042, i32 7, i32 %1028, i32 %988, i32 undef, i64 %1041)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1044 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %1, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1045 = call i32 @dx.op.atomicBinOp.i32(i32 78, %dx.types.Handle %1044, i32 0, i32 %1028, i32 %988, i32 undef, i32 %897)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  br label %1046

; <label>:1046                                    ; preds = %1027, %1019
  %1047 = fsub fast float %1020, %839
  %1048 = fsub fast float %1021, %798
  %1049 = fadd fast float %1022, %796
  %1050 = fadd fast float %1023, 1.000000e+00
  %1051 = fcmp fast ugt float %1050, %1010
  br i1 %1051, label %1052, label %1019

; <label>:1052                                    ; preds = %1046
  br label %1053

; <label>:1053                                    ; preds = %1052, %984
  %1054 = icmp slt i32 %988, %836
  br i1 %1054, label %1055, label %1060

; <label>:1055                                    ; preds = %1053
  %1056 = fadd fast float %985, %838
  %1057 = fadd fast float %986, %797
  %1058 = fsub fast float %987, %795
  %1059 = add nsw i32 %988, 1
  br label %984

; <label>:1060                                    ; preds = %1053
  br label %1062

; <label>:1061                                    ; preds = %964
  br label %1062

; <label>:1062                                    ; preds = %1061, %1060, %786
  %1063 = add i32 %16, 64
  %1064 = add i32 %276, %1063
  %1065 = mul i32 %725, %1064
  %1066 = ashr i32 %1065, 5
  %1067 = shl nsw i32 %1066, 2
  %1068 = add i32 %727, %1067
  %1069 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %10, %dx.types.ResourceProperties { i32 11, i32 0 })  ; AnnotateHandle(res,props)  resource: ByteAddressBuffer
  %1070 = call %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32 139, %dx.types.Handle %1069, i32 %1068, i32 undef, i8 15, i32 4)  ; RawBufferLoad(srv,index,elementOffset,mask,alignment)
  %1071 = extractvalue %dx.types.ResRet.i32 %1070, 0
  %1072 = and i32 %1065, 31
  %1073 = lshr i32 %1071, %1072
  %1074 = icmp eq i32 %1072, 0
  br i1 %1074, label %1080, label %1075

; <label>:1075                                    ; preds = %1062
  %1076 = extractvalue %dx.types.ResRet.i32 %1070, 1
  %1077 = sub i32 0, %1065
  %1078 = and i32 %1077, 31
  %1079 = shl i32 %1076, %1078
  br label %1080

; <label>:1080                                    ; preds = %1075, %1062
  %1081 = phi i32 [ %1079, %1075 ], [ 0, %1062 ]
  %1082 = or i32 %1081, %1073
  %1083 = and i32 %1082, %746
  %1084 = lshr i32 %1082, %267
  %1085 = and i32 %1084, 31
  %1086 = lshr i32 %1082, %750
  %1087 = and i32 %1086, 31
  %1088 = add i32 %1085, %1083
  %1089 = add i32 %1087, %1083
  %1090 = select i1 %228, i32 %1089, i32 %1088
  %1091 = select i1 %228, i32 %1088, i32 %1089
  %1092 = mul i32 %1083, 3
  %1093 = add i32 0, %1092
  %1094 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1093
  %1095 = load float, float addrspace(3)* %1094, align 4
  %1096 = mul i32 %1083, 3
  %1097 = add i32 1, %1096
  %1098 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1097
  %1099 = load float, float addrspace(3)* %1098, align 4
  %1100 = mul i32 %1083, 3
  %1101 = add i32 2, %1100
  %1102 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1101
  %1103 = load float, float addrspace(3)* %1102, align 4
  %1104 = mul i32 %1090, 3
  %1105 = add i32 0, %1104
  %1106 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1105
  %1107 = load float, float addrspace(3)* %1106, align 4
  %1108 = mul i32 %1090, 3
  %1109 = add i32 1, %1108
  %1110 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1109
  %1111 = load float, float addrspace(3)* %1110, align 4
  %1112 = mul i32 %1091, 3
  %1113 = add i32 0, %1112
  %1114 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1113
  %1115 = load float, float addrspace(3)* %1114, align 4
  %1116 = mul i32 %1091, 3
  %1117 = add i32 1, %1116
  %1118 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1117
  %1119 = load float, float addrspace(3)* %1118, align 4
  %1120 = icmp ult i32 %1063, %275
  br i1 %1120, label %1121, label %1395, !dx.controlflow.hints !34

; <label>:1121                                    ; preds = %1080
  %1122 = mul i32 %1091, 3
  %1123 = add i32 2, %1122
  %1124 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1123
  %1125 = load float, float addrspace(3)* %1124, align 4
  %1126 = mul i32 %1090, 3
  %1127 = add i32 2, %1126
  %1128 = getelementptr [768 x float], [768 x float] addrspace(3)* @"\01?GroupVerts@@3PAV?$vector@M$02@@A.v.1dim", i32 0, i32 %1127
  %1129 = load float, float addrspace(3)* %1128, align 4
  %1130 = fsub fast float %1107, %1095
  %1131 = fsub fast float %1111, %1099
  %1132 = fsub fast float %1115, %1095
  %1133 = fsub fast float %1119, %1099
  %1134 = fmul fast float %1133, %1130
  %1135 = fmul fast float %1132, %1131
  %1136 = fsub fast float %1134, %1135
  %1137 = fcmp ult float %1136, 0.000000e+00
  %1138 = call float @dx.op.binary.f32(i32 36, float %1107, float %1115)  ; FMin(a,b)
  %1139 = call float @dx.op.binary.f32(i32 36, float %1095, float %1138)  ; FMin(a,b)
  %1140 = call float @dx.op.binary.f32(i32 36, float %1111, float %1119)  ; FMin(a,b)
  %1141 = call float @dx.op.binary.f32(i32 36, float %1099, float %1140)  ; FMin(a,b)
  %1142 = call float @dx.op.binary.f32(i32 35, float %1107, float %1115)  ; FMax(a,b)
  %1143 = call float @dx.op.binary.f32(i32 35, float %1095, float %1142)  ; FMax(a,b)
  %1144 = call float @dx.op.binary.f32(i32 35, float %1111, float %1119)  ; FMax(a,b)
  %1145 = call float @dx.op.binary.f32(i32 35, float %1099, float %1144)  ; FMax(a,b)
  %1146 = fadd fast float %1139, 1.270000e+02
  %1147 = fadd fast float %1141, 1.270000e+02
  %1148 = fmul fast float %1146, 3.906250e-03
  %1149 = fmul fast float %1147, 3.906250e-03
  %1150 = call float @dx.op.unary.f32(i32 27, float %1148)  ; Round_ni(value)
  %1151 = call float @dx.op.unary.f32(i32 27, float %1149)  ; Round_ni(value)
  %1152 = fptosi float %1150 to i32
  %1153 = fptosi float %1151 to i32
  %1154 = fadd fast float %1143, -1.290000e+02
  %1155 = fadd fast float %1145, -1.290000e+02
  %1156 = fmul fast float %1154, 3.906250e-03
  %1157 = fmul fast float %1155, 3.906250e-03
  %1158 = call float @dx.op.unary.f32(i32 27, float %1156)  ; Round_ni(value)
  %1159 = call float @dx.op.unary.f32(i32 27, float %1157)  ; Round_ni(value)
  %1160 = fptosi float %1158 to i32
  %1161 = fptosi float %1159 to i32
  %1162 = call i32 @dx.op.binary.i32(i32 37, i32 %1152, i32 %207)  ; IMax(a,b)
  %1163 = call i32 @dx.op.binary.i32(i32 37, i32 %1153, i32 %208)  ; IMax(a,b)
  %1164 = call i32 @dx.op.binary.i32(i32 38, i32 %1160, i32 %829)  ; IMin(a,b)
  %1165 = call i32 @dx.op.binary.i32(i32 38, i32 %1161, i32 %830)  ; IMin(a,b)
  %1166 = add i32 %1162, 63
  %1167 = add i32 %1163, 63
  %1168 = call i32 @dx.op.binary.i32(i32 38, i32 %1164, i32 %1166)  ; IMin(a,b)
  %1169 = call i32 @dx.op.binary.i32(i32 38, i32 %1165, i32 %1167)  ; IMin(a,b)
  %1170 = fsub fast float -0.000000e+00, %1131
  %1171 = fsub fast float %1107, %1115
  %1172 = fsub fast float %1111, %1119
  %1173 = sitofp i32 %1162 to float
  %1174 = sitofp i32 %1163 to float
  %1175 = fmul fast float %1173, 2.560000e+02
  %1176 = fmul fast float %1174, 2.560000e+02
  %1177 = fadd fast float %1175, 1.280000e+02
  %1178 = fadd fast float %1176, 1.280000e+02
  %1179 = fsub fast float %1095, %1177
  %1180 = fsub fast float %1099, %1178
  %1181 = fsub fast float %1107, %1177
  %1182 = fsub fast float %1111, %1178
  %1183 = fsub fast float %1115, %1177
  %1184 = fsub fast float %1119, %1178
  %1185 = fmul fast float %1181, %1172
  %1186 = fmul fast float %1182, %1171
  %1187 = fsub fast float %1185, %1186
  %1188 = fmul fast float %1183, %1133
  %1189 = fmul fast float %1184, %1132
  %1190 = fsub fast float %1188, %1189
  %1191 = fmul fast float %1179, %1170
  %1192 = fmul fast float %1180, %1130
  %1193 = fadd fast float %1192, %1191
  %1194 = fsub fast float 1.000000e+00, %1171
  %1195 = call float @dx.op.unary.f32(i32 7, float %1194)  ; Saturate(value)
  %1196 = fadd fast float %1195, %1172
  %1197 = call float @dx.op.unary.f32(i32 7, float %1196)  ; Saturate(value)
  %1198 = fsub fast float %1187, %1197
  %1199 = fsub fast float 1.000000e+00, %1132
  %1200 = call float @dx.op.unary.f32(i32 7, float %1199)  ; Saturate(value)
  %1201 = fadd fast float %1200, %1133
  %1202 = call float @dx.op.unary.f32(i32 7, float %1201)  ; Saturate(value)
  %1203 = fsub fast float %1190, %1202
  %1204 = fadd fast float %1130, 1.000000e+00
  %1205 = call float @dx.op.unary.f32(i32 7, float %1204)  ; Saturate(value)
  %1206 = fsub fast float %1205, %1131
  %1207 = call float @dx.op.unary.f32(i32 7, float %1206)  ; Saturate(value)
  %1208 = fsub fast float %1193, %1207
  %1209 = fmul fast float %1198, 3.906250e-03
  %1210 = fmul fast float %1203, 3.906250e-03
  %1211 = fmul fast float %1208, 3.906250e-03
  %1212 = fsub fast float %1129, %1103
  %1213 = fsub fast float %1125, %1103
  %1214 = fadd fast float %1203, %1198
  %1215 = fadd fast float %1214, %1208
  %1216 = fmul fast float %1215, 3.906250e-03
  %1217 = fdiv fast float %1212, %1216
  %1218 = fdiv fast float %1213, %1216
  %1219 = icmp sge i32 %1168, %1162
  %1220 = icmp sle i32 %1163, %1169
  %1221 = and i1 %1219, %1220
  %1222 = and i1 %1137, %1221
  br i1 %1222, label %1223, label %1395

; <label>:1223                                    ; preds = %1121
  %1224 = shl i32 %57, 7
  %1225 = add i32 %1224, 128
  %1226 = or i32 %1225, %1064
  %1227 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %14, i32 7)  ; CBufferLoadLegacy(handle,regIndex)
  %1228 = extractvalue %dx.types.CBufRet.i32 %1227, 2
  %1229 = lshr i32 %1228, 6
  %1230 = and i32 %1229, 1
  %1231 = sub nsw i32 %1168, %1162
  %1232 = icmp sgt i32 %1231, 4
  %1233 = call i1 @dx.op.waveAnyTrue(i32 113, i1 %1232)  ; WaveAnyTrue(cond)
  br i1 %1233, label %1304, label %1234

; <label>:1234                                    ; preds = %1223
  br label %1235

; <label>:1235                                    ; preds = %1299, %1234
  %1236 = phi float [ %1300, %1299 ], [ %1209, %1234 ]
  %1237 = phi float [ %1301, %1299 ], [ %1210, %1234 ]
  %1238 = phi float [ %1302, %1299 ], [ %1211, %1234 ]
  %1239 = phi i32 [ %1303, %1299 ], [ %1163, %1234 ]
  %1240 = call float @dx.op.binary.f32(i32 36, float %1237, float %1238)  ; FMin(a,b)
  %1241 = call float @dx.op.binary.f32(i32 36, float %1236, float %1240)  ; FMin(a,b)
  %1242 = fcmp fast ult float %1241, 0.000000e+00
  br i1 %1242, label %1261, label %1243

; <label>:1243                                    ; preds = %1235
  %1244 = fmul fast float %1237, %1217
  %1245 = fadd fast float %1244, %1103
  %1246 = fmul fast float %1238, %1218
  %1247 = fadd fast float %1245, %1246
  %1248 = call float @dx.op.unary.f32(i32 7, float %1247)  ; Saturate(value)
  %1249 = bitcast float %1248 to i32
  %1250 = zext i32 %1249 to i64
  %1251 = shl nuw i64 %1250, 32
  %1252 = zext i32 %1226 to i64
  %1253 = or i64 %1251, %1252
  %1254 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %3, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1255 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1254, i32 7, i32 %1162, i32 %1239, i32 undef, i64 %1253)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1256 = or i64 %1251, 2
  %1257 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %2, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1258 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1257, i32 7, i32 %1162, i32 %1239, i32 undef, i64 %1256)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1259 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %1, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1260 = call i32 @dx.op.atomicBinOp.i32(i32 78, %dx.types.Handle %1259, i32 0, i32 %1162, i32 %1239, i32 undef, i32 %1230)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  br label %1261

; <label>:1261                                    ; preds = %1243, %1235
  %1262 = icmp sgt i32 %1168, %1162
  br i1 %1262, label %1263, label %1297

; <label>:1263                                    ; preds = %1261
  br label %1264

; <label>:1264                                    ; preds = %1294, %1263
  %1265 = phi float [ %1269, %1294 ], [ %1236, %1263 ]
  %1266 = phi float [ %1270, %1294 ], [ %1237, %1263 ]
  %1267 = phi float [ %1271, %1294 ], [ %1238, %1263 ]
  %1268 = phi i32 [ %1272, %1294 ], [ %1162, %1263 ]
  %1269 = fsub fast float %1265, %1172
  %1270 = fsub fast float %1266, %1133
  %1271 = fadd fast float %1267, %1131
  %1272 = add nsw i32 %1268, 1
  %1273 = call float @dx.op.binary.f32(i32 36, float %1270, float %1271)  ; FMin(a,b)
  %1274 = call float @dx.op.binary.f32(i32 36, float %1269, float %1273)  ; FMin(a,b)
  %1275 = fcmp fast ult float %1274, 0.000000e+00
  br i1 %1275, label %1294, label %1276

; <label>:1276                                    ; preds = %1264
  %1277 = fmul fast float %1270, %1217
  %1278 = fadd fast float %1277, %1103
  %1279 = fmul fast float %1271, %1218
  %1280 = fadd fast float %1278, %1279
  %1281 = call float @dx.op.unary.f32(i32 7, float %1280)  ; Saturate(value)
  %1282 = bitcast float %1281 to i32
  %1283 = zext i32 %1282 to i64
  %1284 = shl nuw i64 %1283, 32
  %1285 = zext i32 %1226 to i64
  %1286 = or i64 %1284, %1285
  %1287 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %3, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1288 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1287, i32 7, i32 %1272, i32 %1239, i32 undef, i64 %1286)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1289 = or i64 %1284, 2
  %1290 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %2, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1291 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1290, i32 7, i32 %1272, i32 %1239, i32 undef, i64 %1289)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1292 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %1, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1293 = call i32 @dx.op.atomicBinOp.i32(i32 78, %dx.types.Handle %1292, i32 0, i32 %1272, i32 %1239, i32 undef, i32 %1230)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  br label %1294

; <label>:1294                                    ; preds = %1276, %1264
  %1295 = icmp eq i32 %1272, %1168
  br i1 %1295, label %1296, label %1264

; <label>:1296                                    ; preds = %1294
  br label %1297

; <label>:1297                                    ; preds = %1296, %1261
  %1298 = icmp slt i32 %1239, %1169
  br i1 %1298, label %1299, label %1394

; <label>:1299                                    ; preds = %1297
  %1300 = fadd fast float %1236, %1171
  %1301 = fadd fast float %1237, %1132
  %1302 = fsub fast float %1238, %1130
  %1303 = add nsw i32 %1239, 1
  br label %1235

; <label>:1304                                    ; preds = %1223
  %1305 = fcmp fast olt float %1172, 0.000000e+00
  %1306 = fcmp fast olt float %1133, 0.000000e+00
  %1307 = fcmp ogt float %1131, -0.000000e+00
  %1308 = fdiv fast float 1.000000e+00, %1172
  %1309 = fdiv fast float 1.000000e+00, %1133
  %1310 = fdiv fast float 1.000000e+00, %1170
  %1311 = fcmp fast oeq float %1172, 0.000000e+00
  %1312 = fcmp fast oeq float %1133, 0.000000e+00
  %1313 = fcmp oeq float %1131, -0.000000e+00
  %1314 = select i1 %1311, float 1.000000e+08, float %1308
  %1315 = select i1 %1312, float 1.000000e+08, float %1309
  %1316 = select i1 %1313, float 1.000000e+08, float %1310
  br label %1317

; <label>:1317                                    ; preds = %1388, %1304
  %1318 = phi float [ %1209, %1304 ], [ %1389, %1388 ]
  %1319 = phi float [ %1210, %1304 ], [ %1390, %1388 ]
  %1320 = phi float [ %1211, %1304 ], [ %1391, %1388 ]
  %1321 = phi i32 [ %1163, %1304 ], [ %1392, %1388 ]
  %1322 = fmul fast float %1318, %1314
  %1323 = fmul fast float %1319, %1315
  %1324 = fmul fast float %1320, %1316
  %1325 = select i1 %1305, float %1322, float 0.000000e+00
  %1326 = select i1 %1306, float %1323, float 0.000000e+00
  %1327 = select i1 %1307, float %1324, float 0.000000e+00
  %1328 = fptosi float %1322 to i32
  %1329 = fptosi float %1323 to i32
  %1330 = fptosi float %1324 to i32
  %1331 = select i1 %1305, i32 %1231, i32 %1328
  %1332 = select i1 %1306, i32 %1231, i32 %1329
  %1333 = select i1 %1307, i32 %1231, i32 %1330
  %1334 = sitofp i32 %1331 to float
  %1335 = sitofp i32 %1332 to float
  %1336 = sitofp i32 %1333 to float
  %1337 = call float @dx.op.binary.f32(i32 35, float %1326, float %1327)  ; FMax(a,b)
  %1338 = call float @dx.op.binary.f32(i32 35, float %1325, float %1337)  ; FMax(a,b)
  %1339 = call float @dx.op.unary.f32(i32 28, float %1338)  ; Round_pi(value)
  %1340 = call float @dx.op.binary.f32(i32 36, float %1335, float %1336)  ; FMin(a,b)
  %1341 = call float @dx.op.binary.f32(i32 36, float %1334, float %1340)  ; FMin(a,b)
  %1342 = fadd fast float %1339, %1173
  %1343 = fadd fast float %1341, %1173
  %1344 = fcmp fast ugt float %1342, %1343
  br i1 %1344, label %1386, label %1345

; <label>:1345                                    ; preds = %1317
  %1346 = fmul fast float %1339, %1170
  %1347 = fsub fast float %1320, %1346
  %1348 = fmul fast float %1339, %1133
  %1349 = fsub fast float %1319, %1348
  %1350 = fmul fast float %1339, %1172
  %1351 = fsub fast float %1318, %1350
  br label %1352

; <label>:1352                                    ; preds = %1379, %1345
  %1353 = phi float [ %1380, %1379 ], [ %1351, %1345 ]
  %1354 = phi float [ %1381, %1379 ], [ %1349, %1345 ]
  %1355 = phi float [ %1382, %1379 ], [ %1347, %1345 ]
  %1356 = phi float [ %1383, %1379 ], [ %1342, %1345 ]
  %1357 = call float @dx.op.binary.f32(i32 36, float %1354, float %1355)  ; FMin(a,b)
  %1358 = call float @dx.op.binary.f32(i32 36, float %1353, float %1357)  ; FMin(a,b)
  %1359 = fcmp fast ult float %1358, 0.000000e+00
  br i1 %1359, label %1379, label %1360

; <label>:1360                                    ; preds = %1352
  %1361 = fptoui float %1356 to i32
  %1362 = fmul fast float %1354, %1217
  %1363 = fadd fast float %1362, %1103
  %1364 = fmul fast float %1355, %1218
  %1365 = fadd fast float %1363, %1364
  %1366 = call float @dx.op.unary.f32(i32 7, float %1365)  ; Saturate(value)
  %1367 = bitcast float %1366 to i32
  %1368 = zext i32 %1367 to i64
  %1369 = shl nuw i64 %1368, 32
  %1370 = zext i32 %1226 to i64
  %1371 = or i64 %1369, %1370
  %1372 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %3, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1373 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1372, i32 7, i32 %1361, i32 %1321, i32 undef, i64 %1371)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1374 = or i64 %1369, 2
  %1375 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %2, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1376 = call i64 @dx.op.atomicBinOp.i64(i32 78, %dx.types.Handle %1375, i32 7, i32 %1361, i32 %1321, i32 undef, i64 %1374)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  %1377 = call %dx.types.Handle @dx.op.annotateHandle(i32 216, %dx.types.Handle %1, %dx.types.ResourceProperties { i32 4098, i32 261 })  ; AnnotateHandle(res,props)  resource: RWTexture2D<U32>
  %1378 = call i32 @dx.op.atomicBinOp.i32(i32 78, %dx.types.Handle %1377, i32 0, i32 %1361, i32 %1321, i32 undef, i32 %1230)  ; AtomicBinOp(handle,atomicOp,offset0,offset1,offset2,newValue)
  br label %1379

; <label>:1379                                    ; preds = %1360, %1352
  %1380 = fsub fast float %1353, %1172
  %1381 = fsub fast float %1354, %1133
  %1382 = fadd fast float %1355, %1131
  %1383 = fadd fast float %1356, 1.000000e+00
  %1384 = fcmp fast ugt float %1383, %1343
  br i1 %1384, label %1385, label %1352

; <label>:1385                                    ; preds = %1379
  br label %1386

; <label>:1386                                    ; preds = %1385, %1317
  %1387 = icmp slt i32 %1321, %1169
  br i1 %1387, label %1388, label %1393

; <label>:1388                                    ; preds = %1386
  %1389 = fadd fast float %1318, %1171
  %1390 = fadd fast float %1319, %1132
  %1391 = fsub fast float %1320, %1130
  %1392 = add nsw i32 %1321, 1
  br label %1317

; <label>:1393                                    ; preds = %1386
  br label %1395

; <label>:1394                                    ; preds = %1297
  br label %1395

; <label>:1395                                    ; preds = %1394, %1393, %1121, %1080, %742
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @dx.op.groupId.i32(i32, i32) #0

; Function Attrs: nounwind readnone
declare i32 @dx.op.flattenedThreadIdInGroup.i32(i32) #0

; Function Attrs: nounwind readonly
declare %dx.types.ResRet.i32 @dx.op.rawBufferLoad.i32(i32, %dx.types.Handle, i32, i32, i8, i32) #1

; Function Attrs: nounwind readonly
declare %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32, %dx.types.Handle, i32, i32) #1

; Function Attrs: noduplicate nounwind
declare void @dx.op.barrier(i32, i32) #2

; Function Attrs: nounwind readnone
declare float @dx.op.dot3.f32(i32, float, float, float, float, float, float) #0

; Function Attrs: nounwind readnone
declare float @dx.op.unary.f32(i32, float) #0

; Function Attrs: nounwind readonly
declare %dx.types.ResRet.f32 @dx.op.rawBufferLoad.f32(i32, %dx.types.Handle, i32, i32, i8, i32) #1

; Function Attrs: nounwind readnone
declare float @dx.op.dot2.f32(i32, float, float, float, float) #0

; Function Attrs: nounwind readnone
declare float @dx.op.binary.f32(i32, float, float) #0

; Function Attrs: nounwind readnone
declare i32 @dx.op.binary.i32(i32, i32, i32) #0

; Function Attrs: nounwind
declare i1 @dx.op.waveAnyTrue(i32, i1) #3

; Function Attrs: nounwind
declare i32 @dx.op.atomicBinOp.i32(i32, %dx.types.Handle, i32, i32, i32, i32, i32) #3

; Function Attrs: nounwind
declare i64 @dx.op.atomicBinOp.i64(i32, %dx.types.Handle, i32, i32, i32, i32, i64) #3

; Function Attrs: nounwind readonly
declare %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32, %dx.types.Handle, i32) #1

; Function Attrs: nounwind readnone
declare float @dx.op.tertiary.f32(i32, float, float, float) #0

; Function Attrs: nounwind readnone
declare %dx.types.Handle @dx.op.annotateHandle(i32, %dx.types.Handle, %dx.types.ResourceProperties) #0

; Function Attrs: nounwind readnone
declare %dx.types.Handle @dx.op.createHandleFromBinding(i32, %dx.types.ResBind, i32, i1) #0

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind readonly }
attributes #2 = { noduplicate nounwind }
attributes #3 = { nounwind }

!llvm.ident = !{!0}
!dx.version = !{!1}
!dx.valver = !{!2}
!dx.shaderModel = !{!3}
!dx.resources = !{!4}
!dx.entryPoints = !{!26}

!0 = !{!"dxc(private) 1.7.0.0 (private, 00000000)"}
!1 = !{i32 1, i32 6}
!2 = !{i32 1, i32 7}
!3 = !{!"cs", i32 6, i32 6}
!4 = !{!5, !19, !24, null}
!5 = !{!6, !8, !9, !10, !11, !13, !14, !16, !17}
!6 = !{i32 0, %"class.StructuredBuffer<vector<float, 4> >"* undef, !"", i32 0, i32 0, i32 1, i32 12, i32 0, !7}
!7 = !{i32 1, i32 16}
!8 = !{i32 1, %"class.StructuredBuffer<vector<float, 4> >"* undef, !"", i32 0, i32 1, i32 1, i32 12, i32 0, !7}
!9 = !{i32 2, %struct.ByteAddressBuffer* undef, !"", i32 0, i32 2, i32 1, i32 11, i32 0, null}
!10 = !{i32 3, %struct.ByteAddressBuffer* undef, !"", i32 0, i32 3, i32 1, i32 11, i32 0, null}
!11 = !{i32 4, %"hostlayout.class.StructuredBuffer<FPackedNaniteView>"* undef, !"", i32 0, i32 4, i32 1, i32 12, i32 0, !12}
!12 = !{i32 1, i32 912}
!13 = !{i32 5, %"class.StructuredBuffer<vector<unsigned int, 4> >"* undef, !"", i32 0, i32 5, i32 1, i32 12, i32 0, !7}
!14 = !{i32 6, %"class.StructuredBuffer<vector<unsigned int, 2> >"* undef, !"", i32 0, i32 6, i32 1, i32 12, i32 0, !15}
!15 = !{i32 1, i32 8}
!16 = !{i32 7, %"class.StructuredBuffer<vector<unsigned int, 2> >"* undef, !"", i32 0, i32 7, i32 1, i32 12, i32 0, !15}
!17 = !{i32 8, %"class.Buffer<unsigned int>"* undef, !"", i32 0, i32 8, i32 1, i32 10, i32 0, !18}
!18 = !{i32 0, i32 5}
!19 = !{!20, !22, !23}
!20 = !{i32 0, %"class.RWTexture2D<unsigned long long>"* undef, !"", i32 0, i32 0, i32 1, i32 2, i1 false, i1 false, i1 false, !21}
!21 = !{i32 0, i32 5, i32 3, i32 1}
!22 = !{i32 1, %"class.RWTexture2D<unsigned long long>"* undef, !"", i32 0, i32 1, i32 1, i32 2, i1 false, i1 false, i1 false, !21}
!23 = !{i32 2, %"class.RWTexture2D<unsigned int>"* undef, !"", i32 0, i32 2, i32 1, i32 2, i1 false, i1 false, i1 false, !18}
!24 = !{!25}
!25 = !{i32 0, %"$Globals"* undef, !"", i32 0, i32 0, i32 1, i32 124, null}
!26 = !{void ()* @MicropolyRasterize, !"MicropolyRasterize", null, !4, !27}
!27 = !{i32 0, i64 135790608, i32 4, !28, i32 5, !29}
!28 = !{i32 64, i32 1, i32 1}
!29 = !{i32 0}
!30 = distinct !{!30, !"dx.controlflow.hints", i32 1}
!31 = distinct !{!31, !"dx.controlflow.hints", i32 1}
!32 = distinct !{!32, !"dx.controlflow.hints", i32 1}
!33 = distinct !{!33, !"dx.controlflow.hints", i32 1}
!34 = distinct !{!34, !"dx.controlflow.hints", i32 1}
